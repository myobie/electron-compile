'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeRendererProcess = initializeRendererProcess;

require('./babel-maybefill');

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NB: These are duped in protocol-hook so we can save startup time, make
// sure to run both!
var magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';
var magicGlobalForAppRootDir = '__electron_compile_app_root_dir';

var d = require('debug-electron')('electron-compile:initialize-renderer');

var rendererInitialized = false;

/**
 * Called by our rigged script file at the top of every HTML file to set up
 * the same compilers as the browser process that created us
 *
 * @private
 */
function initializeRendererProcess(readOnlyMode) {
  if (rendererInitialized) return;

  var rootCacheDir = require('electron').remote.getGlobal(magicGlobalForRootCacheDir);
  var appRoot = require('electron').remote.getGlobal(magicGlobalForAppRootDir);
  var compilerHost = null;

  // NB: This has to be synchronous because we need to block HTML parsing
  // until we're set up
  if (readOnlyMode) {
    d('Setting up electron-compile in precompiled mode with cache dir: ' + rootCacheDir);
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);
  } else {
    d('Setting up electron-compile in development mode with cache dir: ' + rootCacheDir);

    var _require = require('./config-parser');

    var createCompilers = _require.createCompilers;

    var compilersByMimeType = createCompilers();

    compilerHost = _compilerHost2.default.createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType);
  }

  require('./x-require');
  require('./require-hook').default(compilerHost);
  rendererInitialized = true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbml0aWFsaXplLXJlbmRlcmVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O1FBa0JnQix5QixHQUFBLHlCOztBQWxCaEI7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQSxJQUFNLDZCQUE2QixtQ0FBbkM7QUFDQSxJQUFNLDJCQUEyQixpQ0FBakM7O0FBRUEsSUFBTSxJQUFJLFFBQVEsZ0JBQVIsRUFBMEIsc0NBQTFCLENBQVY7O0FBRUEsSUFBSSxzQkFBc0IsS0FBMUI7O0FBRUE7Ozs7OztBQU1PLFNBQVMseUJBQVQsQ0FBbUMsWUFBbkMsRUFBaUQ7QUFDdEQsTUFBSSxtQkFBSixFQUF5Qjs7QUFFekIsTUFBSSxlQUFlLFFBQVEsVUFBUixFQUFvQixNQUFwQixDQUEyQixTQUEzQixDQUFxQywwQkFBckMsQ0FBbkI7QUFDQSxNQUFJLFVBQVUsUUFBUSxVQUFSLEVBQW9CLE1BQXBCLENBQTJCLFNBQTNCLENBQXFDLHdCQUFyQyxDQUFkO0FBQ0EsTUFBSSxlQUFlLElBQW5COztBQUVBO0FBQ0E7QUFDQSxNQUFJLFlBQUosRUFBa0I7QUFDaEIsMkVBQXFFLFlBQXJFO0FBQ0EsbUJBQWUsdUJBQWEsbUNBQWIsQ0FBaUQsWUFBakQsRUFBK0QsT0FBL0QsQ0FBZjtBQUNELEdBSEQsTUFHTztBQUNMLDJFQUFxRSxZQUFyRTs7QUFESyxtQkFFdUIsUUFBUSxpQkFBUixDQUZ2Qjs7QUFBQSxRQUVHLGVBRkgsWUFFRyxlQUZIOztBQUdMLFFBQU0sc0JBQXNCLGlCQUE1Qjs7QUFFQSxtQkFBZSx1QkFBYSwyQkFBYixDQUF5QyxZQUF6QyxFQUF1RCxPQUF2RCxFQUFnRSxtQkFBaEUsQ0FBZjtBQUNEOztBQUVELFVBQVEsYUFBUjtBQUNBLFVBQVEsZ0JBQVIsRUFBMEIsT0FBMUIsQ0FBa0MsWUFBbEM7QUFDQSx3QkFBc0IsSUFBdEI7QUFDRCIsImZpbGUiOiJpbml0aWFsaXplLXJlbmRlcmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2JhYmVsLW1heWJlZmlsbCc7XG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XG5cbi8vIE5COiBUaGVzZSBhcmUgZHVwZWQgaW4gcHJvdG9jb2wtaG9vayBzbyB3ZSBjYW4gc2F2ZSBzdGFydHVwIHRpbWUsIG1ha2Vcbi8vIHN1cmUgdG8gcnVuIGJvdGghXG5jb25zdCBtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpciA9ICdfX2VsZWN0cm9uX2NvbXBpbGVfcm9vdF9jYWNoZV9kaXInO1xuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWctZWxlY3Ryb24nKSgnZWxlY3Ryb24tY29tcGlsZTppbml0aWFsaXplLXJlbmRlcmVyJyk7XG5cbmxldCByZW5kZXJlckluaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogQ2FsbGVkIGJ5IG91ciByaWdnZWQgc2NyaXB0IGZpbGUgYXQgdGhlIHRvcCBvZiBldmVyeSBIVE1MIGZpbGUgdG8gc2V0IHVwXG4gKiB0aGUgc2FtZSBjb21waWxlcnMgYXMgdGhlIGJyb3dzZXIgcHJvY2VzcyB0aGF0IGNyZWF0ZWQgdXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlbmRlcmVyUHJvY2VzcyhyZWFkT25seU1vZGUpIHtcbiAgaWYgKHJlbmRlcmVySW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICBsZXQgcm9vdENhY2hlRGlyID0gcmVxdWlyZSgnZWxlY3Ryb24nKS5yZW1vdGUuZ2V0R2xvYmFsKG1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyKTtcbiAgbGV0IGFwcFJvb3QgPSByZXF1aXJlKCdlbGVjdHJvbicpLnJlbW90ZS5nZXRHbG9iYWwobWFnaWNHbG9iYWxGb3JBcHBSb290RGlyKTtcbiAgbGV0IGNvbXBpbGVySG9zdCA9IG51bGw7XG5cbiAgLy8gTkI6IFRoaXMgaGFzIHRvIGJlIHN5bmNocm9ub3VzIGJlY2F1c2Ugd2UgbmVlZCB0byBibG9jayBIVE1MIHBhcnNpbmdcbiAgLy8gdW50aWwgd2UncmUgc2V0IHVwXG4gIGlmIChyZWFkT25seU1vZGUpIHtcbiAgICBkKGBTZXR0aW5nIHVwIGVsZWN0cm9uLWNvbXBpbGUgaW4gcHJlY29tcGlsZWQgbW9kZSB3aXRoIGNhY2hlIGRpcjogJHtyb290Q2FjaGVEaXJ9YCk7XG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgZChgU2V0dGluZyB1cCBlbGVjdHJvbi1jb21waWxlIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aCBjYWNoZSBkaXI6ICR7cm9vdENhY2hlRGlyfWApO1xuICAgIGNvbnN0IHsgY3JlYXRlQ29tcGlsZXJzIH0gPSByZXF1aXJlKCcuL2NvbmZpZy1wYXJzZXInKTtcbiAgICBjb25zdCBjb21waWxlcnNCeU1pbWVUeXBlID0gY3JlYXRlQ29tcGlsZXJzKCk7XG5cbiAgICBjb21waWxlckhvc3QgPSBDb21waWxlckhvc3QuY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSk7XG4gIH1cblxuICByZXF1aXJlKCcuL3gtcmVxdWlyZScpO1xuICByZXF1aXJlKCcuL3JlcXVpcmUtaG9vaycpLmRlZmF1bHQoY29tcGlsZXJIb3N0KTtcbiAgcmVuZGVyZXJJbml0aWFsaXplZCA9IHRydWU7XG59XG4iXX0=